---
title: "Vulkan Renderer"
excerpt: "A Vulkan Renderer built from scratch in C++"
---

<!--
   Copyright 2022 Henry R. Chronowski

   Built from Daniel Buckstein's template at https://dbuckstein.github.io/

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->


<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


[Home](/projects/../)

[Blog](/blog/)

[Projects](/projects/)

[About](/about/)


# Vulkan Renderer

<iframe width="560" height="315" src="https://www.youtube.com/embed/VDSvJHASrYY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

    This is a project that I am actively working on with [Ethan Heil](http://www.ethanheil.com/VulkanRenderer.html) with the dual goals of learning the Vulkan API and improving my skills and knowledge of graphics programming. We now have the renderer loading a 3D .obj file of a Utah teapot and mapping a texture to it, with a controllable camera, Phong lighting, and a wireframe rendering mode. Additionally, Ethan has integrated [ImGui](https://github.com/ocornut/imgui) in order to create a debug interface, allowing modifications of uniforms and other variables during runtime. From here I would like to implement more advanced lighting, eventually working up to PBR with global illumination as well as ray and path-traced rendering modes, as well as add the capability for multiple objects and a skybox. Below I go over the parts that I had primary responsibility for and challenges I faced; Please visit Ethan Heil's site to see his work on the project.


## Model Loading

    Having attempted to write a file parser for 3D object files I elected to make use of a couple common libraries for this application, utilizing tinyobjloader for parsing .obj and .mtl files and stb_image for texture parsing. Although these have made focusing on the actual graphics engineering side significantly easier I would like to revisit this at a later date and build custom parsers for the renderer. Once I figured out how to properly interact with the Vulkan data structures, getting the information from the libraries into the format Vulkan wanted ended up being surprisingly easy.

## General Program Architecture

    A large goal moving out of our first pass with this renderer was to fully restructure the architecture of the project. Initially as an aspect of both our laziness and the sources which we were referencing this renderer started out as a single file program. This is to put it mildly unsustainable for a large, complex project. However, designing the architecture for this project was no small undertaking. The biggest concern was encapsulation, making sure that each seperate part of the program only had access to the data and libraries that it needed. The issue with this is that due to our initial design a great deal of our work was associated with other parts, requiring major restructuring in order to improve scaleability. It was an issue that needed to be tackled though, and the only way to deal with it was to sit down and puzzle out what needed what access. The end result is not exactly the gleaming paragon of good software design that we hoped for, but this is something that we can now continue to improve upon.

## Phong Lighting

    We have finally achieved what was previously the bare minimum goal of implementing the Phong lighting model, with lighting data being passed through a seperate uniform buffer, allowing for runtime modification of lighting data on the CPU. Getting to this point has taken more work than I thought possible, although most of it had nothing to do with the specifics of lighting implementation.

    After exploring many different avenues and reading hundreds of lines of documentation, I discovered a small aspect of Vulkan that I have yet to run into working in other frameworks (Although I have not work from scratch in other frameworks so it may exist): Memory alignment of buffers. We discovered this after a several hour long session of bugfixing ended with us adjusting the position of the light and the color changing. Our issue on the backend was that our uniform buffer was not packed properly, and thus even though the correct data was being sent from the CPU to the GPU, when it arrived at the GPU it was in a different organization than expected, and thus did not have the desired qualities. The way to solve this is simply packing the memory following Vulkan's specifications, mostly by using alignas() in order to ensure that all variables sent were aligned on the 16. This small, insignificant sounding backend issue held up our implementation of lighting for weeks, but in practice it's these kind of bugs that are so hard to diagnose, because the program is just doing what you're telling it to. Dealing with memory alignment specifically is a pain, even more so in the context of data being sent between the CPU and GPU, because there are not many tools to debug shaders in the way that we are accustomed to being able to examine the memory of a program running on the CPU during execution. As a result, debugging has to take a more roundabout approach, often with more trial and error.

    Dealing with this issue more or less encapsulates my experience with Vulkan though. As I am sure any naturally curious programmer would, after realizing and resolving this issue I had the immediate question of why. When it comes down to it, as with almost everything else in Vulkan, the need to specifically align your buffer memory comes down to eking out every last tiny miniscule bit of optimization that you can from your program. When you have the capability to specifically align how your variables are stored in memory according to Vulkan's standard, you can orchestrate their positioning to minimize the size of the buffer by doing stuff like using a 4 byte scalar to pad out a 12 byte vector 3 in order to align the memory by 16. I know this doesn't sound like much, but Vulkan is all about cutting out everything single thing that you don't explicitly need, no matter how small, and having minute control over the functioning of your software. In this modern graphics landscape a 16 byte difference in the size of a buffer can be a huge deal when working with computationally hungry realistic rendering techniques like path tracing. With other APIs you don't always have the minute control necessary to have these optimizations, and this can be the difference between an application being capable of real-time rendering and not.

## Future Plans

    If we are being honest we would like to explore every corner of graphics programming with this renderer, but we are only human so we will have to settle for less. Our eventual goal of this is to have an application similar to something like Shadertoy, where users are able to plug their shaders in and play around with settings, seeing the results rendered. Personally, I have chosen this goal as it allows us a way to demonstrate and expend our graphics knowledge while providing a tool that may assist others in the profession.


***Henry Chronowski***
